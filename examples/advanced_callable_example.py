import numpy as np
import sympy
import matplotlib.pyplot as plt
import esr.generation.duplicate_checker as duplicate_checker
import os
import random
import shutil

# 1. Set up parameters for function generation
complexity = 5
# Use a predefined runname from the ESR library
runname = "osc_maths"

print(f"Generating functions with complexity {complexity} for run '{runname}'...")

# 2. Generate and process equations using the main entry point from the library
try:
    duplicate_checker.main(runname, complexity)
except SystemExit:
    # The duplicate_checker.main function calls quit(), so we catch the SystemExit
    pass

print("\nFunction generation and processing complete.")

# 3. Read the generated functions from the file
# The files are saved in the ESR library's function_library directory
import esr.generation.generator as generator
library_dir = os.path.abspath(os.path.join(os.path.dirname(generator.__file__), '..', 'function_library'))
eq_filename = os.path.join(library_dir, runname, f"compl_{complexity}", f"unique_equations_{complexity}.txt")
try:
    with open(eq_filename, "r") as f:
        all_functions = [line.strip() for line in f.readlines() if line.strip()]
except FileNotFoundError:
    print(f"Could not find file with generated equations: {eq_filename}")
    exit()


if not all_functions:
    print("No functions were generated. Exiting.")
    exit()

print(f"Found {len(all_functions)} unique functions.")

# 4. Pick a random function and try to process it
max_attempts = 50  # Maximum number of functions to try
attempt = 0
success = False

while not success and attempt < max_attempts:
    attempt += 1
    func_string = random.choice(all_functions)
    print(f"\nAttempt {attempt}: Randomly selected function: '{func_string}'")

    # 5. Convert the string to a sympy expression
    x = sympy.symbols('x', real=True)
    # Create parameter symbols a0, a1, a2, etc.
    a_symbols = sympy.symbols([f'a{i}' for i in range(10)], real=True)
    
    # Define locals for sympy to understand the function string
    locs = {'x': x, 'sin': sympy.sin, 'cos': sympy.cos, 'inv': lambda x: 1/x, 
            'Abs': sympy.Abs, 'pow': sympy.Pow, 'exp': sympy.exp, 'log': sympy.log}
    
    # Add parameter symbols to locs
    for i, a_sym in enumerate(a_symbols):
        locs[f'a{i}'] = a_sym

    # Try to process the function
    try:
        # Parse the function string
        expr = sympy.sympify(func_string, locals=locs)
        
        # Check if the expression has any parameter symbols and substitute them
        param_symbols = [sym for sym in expr.free_symbols if str(sym).startswith('a')]
        if param_symbols:
            substitutions = {}
            for param in param_symbols:
                # Use different ranges for different parameters to make functions more interesting
                if 'a0' in str(param):
                    val = np.random.uniform(0.5, 2.0)
                else:
                    val = np.random.uniform(0.1, 1.5)
                substitutions[param] = val
                print(f"Substituted '{param}' with {val:.2f}")
            expr = expr.subs(substitutions)

        print(f"Sympy expression: {expr}")

        # 6. Convert the sympy expression to a callable Python function
        callable_func = sympy.lambdify([x], expr, modules=['numpy'])
        print(f"Generated callable function: {callable_func}")

        # 7. Test the callable function with a small range first
        x_test = np.linspace(-1, 1, 10)
        y_test = callable_func(x_test)
        
        # Check for invalid values (inf, nan)
        if np.any(np.isinf(y_test)) or np.any(np.isnan(y_test)):
            print(f"Function produces invalid values (inf/nan), trying another function...")
            continue
            
        # If we get here, the function is valid
        success = True
        
        # 8. Generate full range for plotting
        x_vals = np.linspace(-2 * np.pi, 2 * np.pi, 400)
        y_vals = callable_func(x_vals)
        
        # Handle potential inf/nan values in the full range
        finite_mask = np.isfinite(y_vals)
        if np.sum(finite_mask) < len(y_vals) * 0.5:  # If more than half are invalid
            print(f"Function produces too many invalid values, trying another function...")
            success = False
            continue
            
        # Clip extreme values for better visualization
        y_vals = np.clip(y_vals, -100, 100)

        # 9. Plot the results
        plt.figure(figsize=(10, 6))
        plt.plot(x_vals, y_vals, label=f'f(x) = {func_string}', linewidth=1.5)
        plt.xlabel('x')
        plt.ylabel('f(x)')
        plt.title('Plot of a Randomly Selected Function Generated by ESR')
        plt.legend()
        plt.grid(True)
        plt.ylim(-20, 20)  # Reasonable y-axis limits
        plot_filename = 'advanced_callable_example.png'
        plt.savefig(plot_filename, dpi=150, bbox_inches='tight')
        plt.show()

        print(f"\nPlot saved as {plot_filename}")

    except Exception as e:
        print(f"Could not process the function '{func_string}'. Error: {e}")
        print("Trying another function...")

if not success:
    print(f"\nCould not find a valid function after {max_attempts} attempts.")

print(f"\nExample complete. Generated equations are stored in: {library_dir}/{runname}/compl_{complexity}/")